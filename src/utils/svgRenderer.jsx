/**
 * SVG Renderer for Lucid diagram data.
 * Converts shapes/lines from generateLucidDiagram() into React SVG elements.
 */
import React from 'react';

/**
 * Compute the SVG viewBox from all shape bounding boxes, with 20px padding.
 */
export function computeViewBox(shapes) {
  if (!shapes.length) return { x: 0, y: 0, width: 800, height: 600 };

  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  for (const s of shapes) {
    const { x, y, w, h } = s.boundingBox;
    if (x < minX) minX = x;
    if (y < minY) minY = y;
    if (x + w > maxX) maxX = x + w;
    if (y + h > maxY) maxY = y + h;
  }

  const pad = 20;
  return {
    x: minX - pad,
    y: minY - pad,
    width: maxX - minX + 2 * pad,
    height: maxY - minY + 2 * pad,
  };
}

/**
 * Parse stroke dasharray from style string.
 */
function dashArray(style, width) {
  if (style === 'dashed') return `${width * 4} ${width * 3}`;
  if (style === 'dotted') return `${width} ${width * 2}`;
  return 'none';
}

/**
 * Check if a color is transparent (e.g. #00000000 or #0000).
 */
function isTransparent(color) {
  if (!color) return true;
  const c = color.replace('#', '');
  // 8-char hex with 00 alpha, or 4-char hex with 0 alpha
  if (c.length === 8 && c.slice(6) === '00') return true;
  if (c.length === 4 && c[3] === '0') return true;
  return false;
}

/**
 * Render a rectangle shape as SVG <rect>.
 */
export function renderRectangle(shape) {
  const { x, y, w, h } = shape.boundingBox;
  const fill = shape.style?.fill?.color || '#cccccc';
  const stroke = shape.style?.stroke || {};
  const strokeColor = isTransparent(stroke.color) ? 'none' : (stroke.color || 'none');
  const strokeWidth = stroke.width || 1;
  const strokeStyle = stroke.style || 'solid';
  const rounding = shape.style?.rounding || 0;

  return (
    <rect
      key={shape.id}
      x={x}
      y={y}
      width={w}
      height={h}
      rx={rounding}
      ry={rounding}
      fill={fill}
      stroke={strokeColor}
      strokeWidth={strokeWidth}
      strokeDasharray={dashArray(strokeStyle, strokeWidth)}
    />
  );
}

/**
 * Render a text shape using <foreignObject> wrapping a div with dangerouslySetInnerHTML.
 * This is required because shape text contains <p style="...">, <ul><li>, etc.
 * The HTML is generated by our own lucidDiagramData.js, so it's safe.
 */
export function renderText(shape) {
  const { x, y, w, h } = shape.boundingBox;
  const html = shape.text || '';
  if (!html) return null;

  return (
    <foreignObject key={shape.id} x={x} y={y} width={w} height={h}>
      <div
        xmlns="http://www.w3.org/1999/xhtml"
        style={{
          width: '100%',
          height: '100%',
          fontFamily: "'IBM Plex Sans', sans-serif",
          overflow: 'hidden',
          lineHeight: 1.4,
          boxSizing: 'border-box',
        }}
        dangerouslySetInnerHTML={{ __html: html }}
      />
    </foreignObject>
  );
}

/**
 * Render a rectangleContainer shape: background rect + optional note label.
 */
export function renderContainer(shape) {
  const { x, y, w, h } = shape.boundingBox;
  const fill = shape.style?.fill?.color || '#f0f0f0';
  const stroke = shape.style?.stroke || {};
  const strokeColor = isTransparent(stroke.color) ? 'none' : (stroke.color || '#ccc');
  const strokeWidth = stroke.width || 2;
  const strokeStyle = stroke.style || 'solid';
  const rounding = shape.style?.rounding || 0;

  const elements = [
    <rect
      key={`${shape.id}-bg`}
      x={x}
      y={y}
      width={w}
      height={h}
      rx={rounding}
      ry={rounding}
      fill={fill}
      stroke={strokeColor}
      strokeWidth={strokeWidth}
      strokeDasharray={dashArray(strokeStyle, strokeWidth)}
    />,
  ];

  // Render note property as label text at top-left
  if (shape.note) {
    elements.push(
      <foreignObject
        key={`${shape.id}-note`}
        x={x + 8}
        y={y + 4}
        width={w - 16}
        height={50}
      >
        <div
          xmlns="http://www.w3.org/1999/xhtml"
          style={{
            fontFamily: "'IBM Plex Sans', sans-serif",
            overflow: 'hidden',
            lineHeight: 1.3,
          }}
          dangerouslySetInnerHTML={{ __html: shape.note }}
        />
      </foreignObject>
    );
  }

  return elements;
}

/**
 * Resolve an endpoint's position to absolute coordinates.
 * For shapeEndpoint: uses the relative {x: 0-1, y: 0-1} on the shape's boundingBox.
 * For positionEndpoint: uses the absolute position directly.
 */
function resolveEndpoint(endpoint, shapesById) {
  if (endpoint.type === 'positionEndpoint') {
    return { x: endpoint.position.x, y: endpoint.position.y };
  }

  if (endpoint.type === 'shapeEndpoint') {
    const shape = shapesById[endpoint.shapeId];
    if (!shape) return { x: 0, y: 0 };
    const bb = shape.boundingBox;
    const pos = endpoint.position || { x: 0.5, y: 0.5 };
    return {
      x: bb.x + bb.w * pos.x,
      y: bb.y + bb.h * pos.y,
    };
  }

  return { x: 0, y: 0 };
}

/**
 * Render a line between two endpoints.
 * Draws elbow path: M x1,y1 L midX,y1 L midX,y2 L x2,y2
 * Adds arrowhead via SVG marker reference.
 * Renders text label at midpoint.
 */
export function renderLine(line, shapesById) {
  const p1 = resolveEndpoint(line.endpoint1, shapesById);
  const p2 = resolveEndpoint(line.endpoint2, shapesById);
  const stroke = line.stroke || {};
  const color = stroke.color || '#333333';
  const width = stroke.width || 2;
  const style = stroke.style || 'solid';

  // Build path — elbow routing through midpoint
  const midX = (p1.x + p2.x) / 2;
  const d = `M ${p1.x},${p1.y} L ${midX},${p1.y} L ${midX},${p2.y} L ${p2.x},${p2.y}`;

  const elements = [];

  // Determine marker refs
  const markerEnd = line.endpoint2.style === 'arrow' ? `url(#arrow-${line.id})` : undefined;
  const markerStart = line.endpoint1.style === 'arrow' ? `url(#arrow-start-${line.id})` : undefined;

  elements.push(
    <path
      key={`${line.id}-path`}
      d={d}
      fill="none"
      stroke={color}
      strokeWidth={width}
      strokeDasharray={dashArray(style, width)}
      markerEnd={markerEnd}
      markerStart={markerStart}
    />
  );

  // Render text labels at midpoint
  if (line.text && line.text.length > 0) {
    for (const t of line.text) {
      // Position along the path — for elbow, approximate at midpoint
      const tx = midX;
      const ty = (p1.y + p2.y) / 2;
      elements.push(
        <text
          key={`${line.id}-label-${t.text}`}
          x={tx}
          y={ty - 6}
          textAnchor="middle"
          fill={color}
          fontSize="10"
          fontFamily="'IBM Plex Sans', sans-serif"
          fontWeight="500"
        >
          {t.text}
        </text>
      );
    }
  }

  return elements;
}

/**
 * Generate arrow marker definitions for all lines.
 * Returns array of <marker> elements to place in <defs>.
 */
export function generateMarkers(lines) {
  const markers = [];

  for (const line of lines) {
    const color = line.stroke?.color || '#333333';

    if (line.endpoint2.style === 'arrow') {
      markers.push(
        <marker
          key={`arrow-${line.id}`}
          id={`arrow-${line.id}`}
          markerWidth="10"
          markerHeight="8"
          refX="9"
          refY="4"
          orient="auto"
          markerUnits="strokeWidth"
        >
          <path d="M 0,0 L 10,4 L 0,8 L 2,4 Z" fill={color} />
        </marker>
      );
    }

    if (line.endpoint1.style === 'arrow') {
      markers.push(
        <marker
          key={`arrow-start-${line.id}`}
          id={`arrow-start-${line.id}`}
          markerWidth="10"
          markerHeight="8"
          refX="1"
          refY="4"
          orient="auto"
          markerUnits="strokeWidth"
        >
          <path d="M 10,0 L 0,4 L 10,8 L 8,4 Z" fill={color} />
        </marker>
      );
    }
  }

  return markers;
}

/**
 * Main export: render full diagram data to SVG element pieces.
 * Returns { vb, shapeElements, lineElements, markers }
 *
 * Shapes are rendered in array order: containers first, then rects, then text overlays.
 * This preserves the correct z-order from lucidDiagramData.js.
 */
export function renderDiagramToSVG(diagramData) {
  const { shapes, lines } = diagramData;

  // Build shape lookup by ID
  const shapesById = {};
  for (const s of shapes) {
    shapesById[s.id] = s;
  }

  const vb = computeViewBox(shapes);

  // Render shapes in array order (containers -> rects -> text overlays)
  const shapeElements = [];
  for (const shape of shapes) {
    switch (shape.type) {
      case 'rectangleContainer': {
        const els = renderContainer(shape);
        shapeElements.push(...(Array.isArray(els) ? els : [els]));
        break;
      }
      case 'rectangle':
        shapeElements.push(renderRectangle(shape));
        break;
      case 'text':
        shapeElements.push(renderText(shape));
        break;
      default:
        // Fallback: treat unknown types as rectangles
        shapeElements.push(renderRectangle(shape));
        break;
    }
  }

  // Render lines
  const lineElements = [];
  for (const line of lines) {
    const els = renderLine(line, shapesById);
    lineElements.push(...(Array.isArray(els) ? els : [els]));
  }

  // Generate arrow markers
  const markers = generateMarkers(lines);

  return { vb, shapeElements, lineElements, markers };
}
